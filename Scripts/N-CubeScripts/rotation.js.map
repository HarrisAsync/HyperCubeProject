{"version":3,"sources":["../../src/scripts/rotation.js"],"names":["getRotationMatrix","axis1","axis2","dimension","angle","matrix","Matrix","identity","Math","cos","sin","getAxisName","index","String","fromCharCode","getListOfRotations","list","first","last","push"],"mappings":";;AAAA;AACA;AACA;;AAEA;;;;;;;;AAQA,SAASA,iBAAT,CAA2BC,KAA3B,EAAkCC,KAAlC,EAAyCC,SAAzC,EAAoDC,KAApD,EAA2D;AAC1D;;;;;;;;;;;;;;;;;;;AAmBA,KAAIC,SAASC,OAAOC,QAAP,CAAgBJ,SAAhB,CAAb;;AAEAE,QAAOJ,KAAP,EAAcA,KAAd,IAAuBO,KAAKC,GAAL,CAASL,KAAT,CAAvB;AACAC,QAAOJ,KAAP,EAAcC,KAAd,IAAuB,CAACM,KAAKE,GAAL,CAASN,KAAT,CAAxB;AACAC,QAAOH,KAAP,EAAcD,KAAd,IAAuBO,KAAKE,GAAL,CAASN,KAAT,CAAvB;AACAC,QAAOH,KAAP,EAAcA,KAAd,IAAuBM,KAAKC,GAAL,CAASL,KAAT,CAAvB;;AAEA,QAAOC,MAAP;AACA;;AAGD,SAASM,WAAT,CAAqBC,KAArB,EAA4B;AAC3B;;;;;;;;;;;;AAYA,KAAIA,QAAQ,CAAZ,EAAe;AACd,SAAOC,OAAOC,YAAP,CAAoBF,QAAQ,EAA5B,CAAP;AACA;;AAED,QAAOC,OAAOC,YAAP,CAAoB,KAAKF,KAAzB,CAAP;AACA;;AAGD,SAASG,kBAAT,CAA4BZ,SAA5B,EAAuC;AACtC;;;;;;;;;;;;;;AAcA,KAAIa,OAAO,EAAX;AACA,KAAIC,cAAJ;AAAA,KAAWC,aAAX;;AAEA,MAAKD,QAAM,CAAX,EAAcA,QAAMd,YAAU,CAA9B,EAAiCc,OAAjC,EAA0C;AACzC,OAAKC,OAAKD,QAAM,CAAhB,EAAmBC,OAAKf,SAAxB,EAAmCe,MAAnC,EAA2C;AAC1CF,QAAKG,IAAL,CAAU,CAACF,KAAD,EAAQC,IAAR,CAAV;AACA;AACD;;AAED,QAAOF,IAAP;AACA;;AAED","file":"rotation.js","sourcesContent":["//\r\n// Rotation\r\n//\r\n\r\n/*\r\nNote: \r\nRotation is the rotation of a plane, defined by 2 orthogonal vectors\r\nSo when I say XY rotation, it's the plane defined by the X and Y axes\r\nrotating around the other axes (Z for 3D, ZW for 4D)\r\nhttps://www.fourthdimensionapp.com/4dmanip/ has a great explanation on rotation\r\n*/\r\n\r\nfunction getRotationMatrix(axis1, axis2, dimension, angle) {\r\n\t/*\r\n\tNote:\r\n\tLooking at rotations matrices for 2D, 3D and 4D, we can extrapolate a general formula for them\r\n\tEach axis has a vertical matrix index corresponding to it\r\n\t\t- X --> 0 (1D) ; X_0 --> 0 (1D)\r\n\t\t- Y --> 1 (2D) ; X_1 --> 1 (2D)\r\n\t\t- Z --> 2 (3D) ; X_2 --> 2 (3D)\r\n\t\t- W --> 3 (4D) ; X_3 --> 3 (4D)\r\n\t\t- ...\r\n\t\t- X_{n} --> {n} ({n+1}D)\r\n\tAlgorithm:\r\n\t\t- Generate an identity matrix with dimension {dimension}\r\n\t\t- Replace the following coordinates with the following values\r\n\t\t\t- [axis1, axis1] --> cos(a)\r\n\t\t\t- [axis1, axis2] --> -sin(a)\r\n\t\t\t- [axis2, axis1] --> sin(a)\r\n\t\t\t- [axis2, axis2] --> cos(a)\r\n\t*/\r\n\r\n\tlet matrix = Matrix.identity(dimension)\r\n\r\n\tmatrix[axis1][axis1] = Math.cos(angle)\r\n\tmatrix[axis1][axis2] = -Math.sin(angle)\r\n\tmatrix[axis2][axis1] = Math.sin(angle)\r\n\tmatrix[axis2][axis2] = Math.cos(angle)\r\n\r\n\treturn matrix\r\n}\r\n\r\n\r\nfunction getAxisName(index) {\r\n\t/*\r\n\tNote:\r\n\tTake the index of the axis and get the associated letter\r\n\tUnicode caps alphabet start at 65, 'X' char is at index 65+23 = 88\r\n\t'W' (axis index 3) is at 65+25-3 = 90-3 = 87\r\n\tSo we have X, Y, Z as 0, 1, 2 ; then we do the alphabet in reverse from 'W'\r\n\tI'm not really caring about dimensions larger than 25 because\r\n\t\t- Such a dimension is very laggy\r\n\t\t- String.fromCharCode() doesn't throw an error for negative/large values\r\n\t\t- They will just have weird axis names\r\n\t*/\r\n\t\r\n\tif (index < 3) {\r\n\t\treturn String.fromCharCode(index + 88)\r\n\t}\r\n\r\n\treturn String.fromCharCode(90 - index)\r\n}\r\n\r\n\r\nfunction getListOfRotations(dimension) {\r\n\t/*\r\n\tNote:\r\n\tReturn a list of all the planes you can rotate for a given dimension\r\n\t0D --> []\r\n\t1D --> []\r\n\t2D --> [0 1] --> ['XY']\r\n\t3D --> [0 1, 0 2, 1 2] --> ['XY', 'XZ', 'YZ']\r\n\t4D --> [0 1, 0 2, 0 3, 1 2, 1 3, 2 3] --> ['XY', 'XZ', 'XW', 'YZ', 'YW', 'ZW']\r\n\tPattern:\r\n\t\t- The first digit goes from 0 to dimension-2\r\n\t\t- The last digit goes from the first digit + 1 to dimension-1\r\n\tCombine these two in a loop and BAM!\r\n\t*/\r\n\r\n\tlet list = []\r\n\tlet first, last\r\n\r\n\tfor (first=0; first<dimension-1; first++) {\r\n\t\tfor (last=first+1; last<dimension; last++) {\r\n\t\t\tlist.push([first, last])\r\n\t\t}\r\n\t}\r\n\r\n\treturn list\r\n}\r\n\r\n/*\r\nFun fact:\r\nThe number of rotations per dimension is given by (n-1)*n/2\r\nObservation:\r\n\t- 0D has no rotation possible\r\n\t  (because to rotate you need at least 2 orthogonal vectors (2 axes) that define a plane)\r\n\t- 1D gets the number of rotations for 0D (so 0) and still no rotation possible,\r\n\t  so a total of 0 rotations\r\n\t- 2D gets the number of rotations for 1D (0) + 1 (2 axes = 1 plane)\r\n\t- 3D gets 1 + 2 = 3\r\n\t- 4D gets 3 + 3 = 6\r\n\t- 5D gets 6 + 4 = 10\r\n\t- 6D gets 10 + 5 = 15\r\n\t- Hopefully you see some kind of pattern here\r\nGeneralization:\r\n\t- Every higher dimension {n} gets\r\n\t\t- The rotation planes from the previous dimension {n-1} (obviously)\r\n\t  \t- The number of axes from the previous dimension (so {n-1} axes)\r\n\t  \t  that each can be combined with the new axis to create {n} rotation planes\r\n\t- That translates to a well-know progression:\r\n\t\t- 0, 0, 1, 3, 6, 10, 15, ...\r\n\t\t- u(n) = u(n-1) + n - 1\r\n\t\t- These are the triangular numbers, of general formula\r\n\t\t\t- n(n+1)/2\r\n\t\t\t- 2 choose n+1 (binomial coefficients)\r\n\t\t- We only shift everything over by 1 to correspond with the dimension number\r\n\t\t- More on them: https://en.wikipedia.org/wiki/Triangular_number\r\nProof (copied from http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/runsums/triNbProof.html):\r\n\tT(n) + T(n) = 1 + 2 + 3 + ... + (n-1) + n\r\n\t            + n + (n-1) + ... + 3 + 2 + 1\r\n\t            = (1+n) + (2+[n-1]) + (3+[n-2]) + ... + ([n-1]+2) + (n+1)\r\n\t            = (n+1) + (n+1) + ... + (n+1) + (n+1)\r\n\t            = n*(n+1)\r\n\tT(n) = (T(n) + T(n)) / 2 = n*(n+1)/2\r\n*/"]}