{"version":3,"sources":["../../src/scripts/draw.js"],"names":["draw","ctx","fillStyle","fillRect","WIDTH","HEIGHT","point","rotated","projected","perspective","rotation","points","Array","FIGURE","length","i","Matrix","from","transpose","identity","DIMENSION","j","ROTATIONS","dot","getRotationMatrix","ANGLE","ISOMETRIC","getPerspectiveScalar","getProjectionMatrix","scale","SCALING","drawVertices","connectVertices","SPEED","NEXTFRAME","requestAnimationFrame","beginPath","arc","Math","PI","fill","dimension","step","pow","size","connect","i1","i2","moveTo","lineTo","strokeStyle","stroke","scalar","DISTANCE"],"mappings":"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","file":"draw.js","sourcesContent":["//\r\n// Rendering\r\n//\r\n\r\nfunction draw() {\r\n\t// Clear the screen\r\n\tctx.fillStyle = '#fff'\r\n\tctx.fillRect(-WIDTH/2, -HEIGHT/2, WIDTH, HEIGHT)\r\n\r\n\t// Matrices\r\n\tlet point, rotated, projected\r\n\t// Scalars and indices\r\n\tlet perspective, rotation\r\n\tlet points = new Array(FIGURE.length)\r\n\r\n\t// Rotating, projecting the vertices, and storing them\r\n\tfor (let i=0; i<FIGURE.length; i++) {\r\n\t\tpoint = Matrix.from([FIGURE[i]])\r\n\t\tpoint = Matrix.transpose(point)\r\n\r\n\t\t/*\r\n\t\tNote: Here I'm combining the rotation matrices by dotting them\r\n\t\tStarting out with the identity matrix, this has the effect of leaving the point intact\r\n\t\tif there are no rotations\r\n\t\t*/\r\n\r\n\t\trotated = Matrix.identity(DIMENSION)\r\n\t\tfor (let j=0; j<ROTATIONS.length; j++) {\r\n\t\t\trotation = ROTATIONS[j]\r\n\t\t\trotated = Matrix.dot(rotated, getRotationMatrix(rotation[0], rotation[1], DIMENSION, ANGLE))\r\n\t\t}\r\n\t\trotated = Matrix.dot(rotated, point)\r\n\t\t\r\n\t\t/*\r\n\t\tNote: for every dimension strictly higher than 2\r\n\t\twe are projecting {rotated} from dimension n to n-1, and repeat until we hit 2D \r\n\t\t*/\r\n\r\n\t\tprojected = Matrix.from(rotated)\r\n\t\tfor (let j=DIMENSION; j>2; j--) {\r\n\t\t\tif (ISOMETRIC) {\r\n\t\t\t\tperspective = 1\r\n\t\t\t} else {\r\n\t\t\t\tperspective = getPerspectiveScalar(projected[j-1][0])\r\n\t\t\t}\r\n\t\t\tprojected = Matrix.dot(getProjectionMatrix(j, perspective), projected)\r\n\t\t}\r\n\t\tprojected = Matrix.scale(projected, SCALING)\r\n\r\n\t\tpoints[i] = [projected[0][0], projected[1][0]]\r\n\t}\r\n\r\n\tdrawVertices(points)\r\n\tconnectVertices(points)\r\n\r\n\tANGLE += SPEED\r\n\r\n\tNEXTFRAME = requestAnimationFrame(draw)\r\n}\r\n\r\n\r\nfunction drawVertices(points) {\r\n\t// Pretty self-explanatory\r\n\tfor (let i=0; i<points.length; i++) {\r\n\t\tctx.beginPath()\r\n\t\tctx.arc(points[i][0], points[i][1], 3, 0, 2*Math.PI)\r\n\t\tctx.fillStyle = '#000'\r\n\t\tctx.fill()\r\n\t}\r\n}\r\n\r\n\r\nfunction connectVertices(points) {\r\n\t/*\r\n\tHere is the pattern to connect the vertices correctly\r\n\tThis works for every dimension starting from 1D (2 vertices, connect them together)\r\n\t\t- every 2 points (i%2 === 0): for the next 1 point: connect i and i+1\r\n\t\t- every 4 points (i%4 === 0): for the next 2 points: connect i and i+2\r\n\t\t- every 8 points (i%8 === 0): for the next 4 points: connect i and i+4\r\n\t\t- every 16 points (i%16 === 0): for the next 8 points: connect i and i+8\r\n\t\t- ...\r\n\t\t- every 2^{dimensions}: for the next 2^{dimensions+!}: connect i and i+2^{dimensions-1}\r\n\tI'm calling the every ... points the step, and the number points each step the size  \r\n\t*/\r\n\r\n\tctx.beginPath()\r\n\r\n\tfor (let dimension=1; dimension<DIMENSION+1; dimension++) {\r\n\t\tlet step = Math.pow(2, dimension)\r\n\t\tlet size = Math.pow(2, dimension-1)\r\n\t\tfor (let i=0; i<points.length; i+=step) {\r\n\t\t\tfor (let j=0; j<size; j++) {\r\n\t\t\t\tconnect(i+j, i+j+size)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction connect(i1, i2) {\r\n\t\tctx.moveTo(points[i1][0], points[i1][1])\r\n\t\tctx.lineTo(points[i2][0], points[i2][1])\r\n\t}\r\n\r\n\tctx.strokeStyle = '#000'\r\n\tctx.stroke()\r\n}\r\n\r\n\r\nfunction getPerspectiveScalar(scalar) {\r\n\treturn 1/(DISTANCE + scalar)\r\n}"]}